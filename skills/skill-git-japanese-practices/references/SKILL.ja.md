---
name: skill-git-japanese-practices
description: 日本語コミットメッセージとGitHubフローを実践するためのGit運用ガイド。Conventional Commits形式、原子的コミット、効果的なコードレビューの型を提供します。
author: RyoMurakami1983
tags: [git, github-flow, conventional-commits, japanese, team-practices]
invocable: false
version: 1.0.0
---

# Git日本語プラクティス

**基礎と型 / 成長の複利**を体現するGit運用ガイド。日本語コミットメッセージとGitHubフローで、チーム全体の生産性と学習資産を最大化します。

## 関連スキル

- **`skill-writing-guide`** - Skill執筆のベストプラクティス
- **`skill-quality-validation`** - 64項目品質検証
- **`skill-template-generator`** - テンプレート自動生成
- **`skill-revision-guide`** - 修正・バージョン管理

## このスキルを使うとき

以下の状況で活用してください：

- Conventional Commits形式を導入したい
- 日本語でわかりやすいコミットメッセージを書きたい
- GitHubフローのブランチ戦略を確立したい
- 原子的コミットの実践方法を学びたい
- コードレビュー文化を醸成したい
- チーム全体で一貫したGit運用を実現したい
- コミット履歴を「学習資産」として活用したい

**使わないとき**：
- 個人プロジェクトで履歴管理が不要な場合
- 既に確立されたGit運用ルールがあり変更の余地がない場合

---

## コア原則

このスキルは村上涼の開発憲法に基づき、以下の原則で設計されています：

### 1. 基礎と型：最小形式で最大可能性を解放する

**Conventional Commits** という最小形式を採用することで、チーム全体が統一されたコミット履歴を作成できます。型があるから速く動け、基礎があるから応用が尽きません。

### 2. 成長の複利：コミット履歴が学習資産になる

明確なコミットメッセージは、未来の自分やチームメンバーへの贈り物です。コミット履歴が「なぜその変更をしたのか」を語り、チーム全体の成長を加速させます。

### 3. 暗黙知を形式知に：誰もが使える型にする

個人の経験（暗黙知）を **Conventional Commits形式** や **GitHubフロー** という型（形式知）に変換することで、誰もが再現でき、チームが自律成長します。

### 4. 継続は力：小さなコミットを積み重ねる

巨大なコミットではなく、**原子的コミット**（単一の変更に焦点）を積み重ねることで、長期的な保守性と品質が向上します。

### 5. 温故知新：過去のコミットから学ぶ文化

良いコミット履歴は、プロジェクトの歴史書です。`git log`、`git blame`を活用し、過去の知恵と新しい技術を繋ぎます。

---

## パターン1: Conventional Commits形式

### 概要

Conventional Commitsは、コミットメッセージに一貫した構造を持たせる規約です。この「型」があることで、変更内容の理解、自動化、チーム協業が飛躍的に向上します。

### 基本形式

```
<type>: <subject>

<body>

<footer>
```

### タイプ一覧

| タイプ | 用途 | 例 |
|--------|------|-----|
| `feat` | 新機能の追加 | `feat: ユーザー認証機能を追加` |
| `fix` | バグ修正 | `fix: ログイン時のセッションタイムアウト問題を修正` |
| `docs` | ドキュメント更新 | `docs: READMEにインストール手順を追加` |
| `test` | テストの追加・修正 | `test: ユーザー登録のE2Eテストを追加` |
| `refactor` | コード改善（機能追加やバグ修正ではない） | `refactor: ユーザーサービスを関数型に書き換え` |
| `chore` | ビルドプロセスや依存関係の更新 | `chore: Python 3.12にアップグレード` |

### 基本例：シンプルなコミット

```bash
git commit -m "feat: パスワードリセット機能を追加"
```

**なぜこの形式か？**
- 一目で「新機能追加」とわかる
- `git log --oneline`で変更種類を素早く把握できる
- 自動化ツール（CHANGELOG生成等）が活用できる

### 中級例：本文付きコミット

```bash
git commit -m "fix: CSVインポート時の文字化け問題を修正

- Shift_JISエンコーディングを明示的に指定
- BOM付きUTF-8にも対応
- エラーハンドリングを追加

Why: ユーザーから文字化け報告が3件あり、緊急対応が必要だったため"
```

**ポイント**：
- **本文で具体的な変更内容を列挙**
- **Why（なぜ）を明記**し、未来の自分やチームに文脈を伝える
- **暗黙知の言語化**：「なんとなく」ではなく理由を明確に

### 上級例：スコープとBreaking Change

```bash
git commit -m "feat(auth)!: JWT認証をOAuth2.0に移行

- JWTトークン発行ロジックを削除
- OAuth2.0認可コードフローを実装
- 既存のAPIエンドポイント /api/auth/* を変更

BREAKING CHANGE: /api/auth/login エンドポイントが /api/oauth/authorize に変更されました。
クライアント側の変更が必要です。

Why: セキュリティ強化とサードパーティ認証対応のため"
```

**ポイント**：
- **スコープ**（`auth`）で変更範囲を明示
- **`!`マーク**でBreaking Changeを警告
- **BREAKING CHANGE**セクションで影響を詳細説明

### いつスコープを使うか？

| プロジェクト規模 | スコープ推奨度 | 理由 |
|----------------|-------------|------|
| 小規模（1-2人） | 低 | オーバーヘッドが大きい |
| 中規模（3-10人） | 中 | モジュールが明確なら有効 |
| 大規模（10人以上） | 高 | 変更範囲の特定が重要 |

**例**: `feat(api):`, `fix(ui):`, `test(database):`

### 原子的コミットとの関連

Conventional Commitsは **原子的コミット**（後述）と組み合わせることで真価を発揮します：

```bash
# 悪い例：複数の変更を1コミットに
git commit -m "feat: 認証機能追加とUI改善とテスト追加"

# 良い例：変更を分割
git commit -m "feat: JWT認証機能を追加"
git commit -m "refactor: ログインUIのレイアウトを改善"
git commit -m "test: 認証フローのE2Eテストを追加"
```

---

## パターン2: GitHubフロー実践

### 概要

GitHubフローは、シンプルかつ強力なブランチ戦略です。**mainブランチは常にデプロイ可能**、**機能追加はブランチで**、**Pull Requestでレビュー**という3つの柱で構成されます。

### 基本フロー

```
1. mainから新しいブランチを作成
2. コミットを積み重ねる
3. Pull Requestを作成
4. コードレビュー
5. mainにマージ
6. 即座にデプロイ（またはデプロイ可能な状態）
```

### ブランチ命名規則

Conventional Commitsのtypeを活用したプレフィックス：

| プレフィックス | 用途 | 例 |
|--------------|------|-----|
| `feature/` | 新機能開発 | `feature/user-authentication` |
| `fix/` | バグ修正 | `fix/csv-encoding-issue` |
| `refactor/` | コード改善 | `refactor/extract-user-service` |
| `docs/` | ドキュメント更新 | `docs/update-api-reference` |
| `test/` | テスト追加 | `test/add-e2e-login-test` |
| `chore/` | 環境・依存関係更新 | `chore/upgrade-python-312` |

### 基本例：機能追加の流れ

```bash
# 1. mainから最新を取得
git checkout main
git pull origin main

# 2. 機能ブランチを作成
git checkout -b feature/password-reset

# 3. 開発とコミット（原子的に）
git add src/auth/password_reset.py
git commit -m "feat: パスワードリセット機能の基本実装"

git add src/api/routes/auth.py
git commit -m "feat: パスワードリセットAPIエンドポイントを追加"

git add tests/test_password_reset.py
git commit -m "test: パスワードリセット機能のテストを追加"

# 4. リモートにプッシュ
git push origin feature/password-reset

# 5. GitHubでPull Requestを作成
```

### Pull Request作成のベストプラクティス

#### タイトル

Conventional Commits形式を使用：

```
feat: パスワードリセット機能を追加
```

#### 説明テンプレート

```markdown
## 変更内容

- パスワードリセット機能を実装
- メール送信による確認コード生成
- トークンの有効期限管理（24時間）

## なぜこの変更が必要か

ユーザーからパスワード忘れ時の対応要望が多数あり、
サポート工数削減とユーザー体験向上のため。

## 影響範囲

- 新規APIエンドポイント: `POST /api/auth/reset-password`
- 新規データベーステーブル: `password_reset_tokens`
- 環境変数追加: `EMAIL_SMTP_SERVER`, `EMAIL_FROM`

## テスト

- [ ] 単体テスト（pytest）
- [ ] E2Eテスト
- [ ] 手動テスト（メール送信確認）

## スクリーンショット

（UIがある場合は追加）

## チェックリスト

- [ ] コードレビュー準備完了
- [ ] ドキュメント更新済み
- [ ] テストが通過
```

### コードレビューの姿勢

#### レビュワー側

✅ **建設的なフィードバック**：
```markdown
# 良い例
「エラーハンドリングが素晴らしいですね！
ひとつ提案ですが、タイムアウト時のリトライ処理も追加すると
より堅牢になると思います。」

# 悪い例
「エラーハンドリングがない。直して。」
```

✅ **コードに焦点を当てる**（個人攻撃にしない）：
```markdown
# 良い例
「この関数は70行あり、複雑になっています。
小さな関数に分割すると、テストしやすくなりますね。」

# 悪い例
「あなたのコードはいつも長すぎる。」
```

#### 作成者側

✅ **フィードバックを学習機会として歓迎**：
```markdown
# レビューコメントへの返信例
「ご指摘ありがとうございます！
リトライ処理を追加し、指数バックオフも実装しました。
このパターンは他の箇所でも使えそうですね。」
```

✅ **変更の理由と影響を明確に説明**：
PRの説明やコミットメッセージで「Why」を必ず記載。

### マージ戦略

| 戦略 | 使いどころ | メリット | デメリット |
|------|----------|---------|----------|
| **Squash and merge** | 機能ブランチのコミットを1つにまとめたい | mainの履歴がクリーン | 詳細なコミット履歴が失われる |
| **Merge commit** | すべてのコミットを保持したい | 完全な履歴保存 | mainの履歴が複雑になる |
| **Rebase and merge** | 直線的な履歴を維持したい | クリーンで直線的 | コンフリクト解決が難しい場合がある |

**推奨**：
- **小～中規模プロジェクト**: Squash and merge（シンプルな履歴）
- **大規模プロジェクト**: チーム方針に従う（通常はMerge commit）

---

## パターン3: 効果的な日本語コミットメッセージ

### 概要

日本語でのコミットメッセージは、チームメンバー全員が母国語で理解できる強力な利点があります。ただし、「明確で説明的」でなければ、履歴の価値が失われます。

### 基本テンプレート

```
<type>: <主語を省略した簡潔な説明>

- 変更内容1
- 変更内容2
- 変更内容3

Why: <なぜこの変更が必要だったか>
```

### 良い例 vs 悪い例

| 悪い例 | 良い例 | 理由 |
|--------|--------|------|
| `fix: バグ修正` | `fix: CSVインポート時のShift_JISエンコーディングエラーを修正` | 具体的な問題を明示 |
| `feat: 機能追加` | `feat: ユーザープロフィール編集機能を追加` | 何の機能か明確 |
| `update` | `refactor: ユーザー認証ロジックを関数型に書き換え` | typeと具体性 |
| `fix: いろいろ修正` | 3つの独立したコミットに分割 | 原子的コミット |

### 主語の扱い

日本語では主語を省略できますが、**動詞は明確に**：

```bash
# 良い例（簡潔）
git commit -m "feat: ログイン機能を追加"

# 冗長（主語不要）
git commit -m "feat: システムにログイン機能を追加する"

# 曖昧（動詞がない）
git commit -m "feat: ログイン機能"
```

### Whyを説明する重要性

**基礎と型 / 成長の複利** の観点から、「なぜ」は学習資産として最も価値があります：

```bash
# 悪い例：Whyがない
git commit -m "fix: タイムアウトを30秒に変更"

# 良い例：Whyを明記
git commit -m "fix: API呼び出しタイムアウトを10秒→30秒に変更

Why: 大量データ処理時に10秒では不足し、タイムアウトエラーが
頻発していたため。本番環境のログ分析により30秒が適切と判断。"
```

6ヶ月後、この変更を見た人（未来の自分含む）が「なぜ30秒なのか？」をすぐに理解できます。

### 絵文字の使用（オプション）

チームの文化に応じて、絵文字でタイプを視覚化できます：

```bash
✨ feat: 新機能
🐛 fix: バグ修正
📝 docs: ドキュメント
🧪 test: テスト
♻️ refactor: リファクタリング
🔧 chore: 雑務
```

**注意**：絵文字は視認性を高めますが、自動化ツールとの互換性を確認してください。

---

## パターン4: 原子的コミット

### 概要

**原子的コミット**とは、「単一の論理的変更」に焦点を当てたコミットです。1コミット = 1つの責務という原則により、レビュー、リバート、デバッグが劇的に簡単になります。

### なぜ原子的コミットが重要か

| 利点 | 説明 |
|------|------|
| **レビューしやすい** | 1コミットが小さいため、変更内容を素早く理解できる |
| **リバートしやすい** | 問題があるコミットだけを安全に取り消せる |
| **デバッグしやすい** | `git bisect`でバグ混入コミットを特定できる |
| **履歴が読みやすい** | `git log`が「物語」として機能する |

### 悪い例：巨大なコミット

```bash
git commit -m "feat: ユーザー機能とAPI改善とテスト追加"

# 変更ファイル
# src/user/models.py
# src/user/services.py
# src/api/routes.py
# src/api/middleware.py
# tests/test_user.py
# tests/test_api.py
# docs/API.md
```

**問題点**：
- 複数の責務が混在（ユーザー機能 + API改善 + テスト + ドキュメント）
- 一部だけリバートできない
- レビュワーが混乱する

### 良い例：原子的に分割

```bash
# コミット1
git add src/user/models.py
git commit -m "feat: Userモデルにプロフィール画像フィールドを追加"

# コミット2
git add src/user/services.py
git commit -m "feat: プロフィール画像アップロード機能を実装"

# コミット3
git add src/api/routes.py
git commit -m "feat: プロフィール画像アップロードAPIエンドポイントを追加"

# コミット4
git add src/api/middleware.py
git commit -m "refactor: API認証ミドルウェアのエラーハンドリングを改善"

# コミット5
git add tests/test_user.py
git commit -m "test: プロフィール画像アップロード機能のテストを追加"

# コミット6
git add docs/API.md
git commit -m "docs: プロフィール画像APIのドキュメントを追加"
```

**メリット**：
- 各コミットが独立している
- コミット4（API改善）だけ別PRにすることも可能
- レビュワーが段階的に理解できる

### コミット分割の判断基準

**1つのコミットにまとめる条件**：
- [ ] 変更が単一の論理的な目的を持つ
- [ ] 変更ファイルが1～3個程度
- [ ] 変更行数が50行以下（目安）

**分割すべきサイン**：
- [ ] 「〜と〜を追加」のような「と」が入る
- [ ] 異なるモジュール/レイヤーにまたがる
- [ ] コミットメッセージが3行以上になる

### git add -p の活用

部分的なステージングで、ファイル内の変更を分割コミット：

```bash
# ファイル内の一部だけステージング
git add -p src/user/services.py

# 対話的に選択
# y: この変更をステージング
# n: スキップ
# s: さらに小さく分割
# q: 終了

git commit -m "feat: ユーザーサービスにバリデーション追加"

# 残りの変更を別コミット
git add src/user/services.py
git commit -m "refactor: ユーザーサービスのエラーメッセージを改善"
```

---

## ベストプラクティス

### 1. 小さなコミットを積み重ねる（継続は力）

毎日の開発で意識すること：
- 1機能 = 1コミットではなく、1機能 = 3～5コミット
- コミット前に `git diff` で変更を確認
- 関係ない変更（デバッグ用printなど）は含めない

### 2. コミット履歴を学習資産にする（成長の複利）

良いコミット履歴は、チームの知識ベースです：
- `git log --oneline --graph` で全体像を把握
- `git blame` で「なぜこのコードがあるか」を調査
- `git show <commit>` で過去の判断理由を確認

### 3. チーム全体で型を共有する（基礎と型）

`.github/pull_request_template.md` を作成：

```markdown
## 変更内容

## なぜこの変更が必要か

## 影響範囲

## テスト

- [ ] 単体テスト
- [ ] E2Eテスト

## チェックリスト

- [ ] Conventional Commits形式でコミット
- [ ] 原子的コミットに分割
- [ ] ドキュメント更新済み
```

### 4. コミット前のチェックリスト

```bash
# 1. 変更内容を確認
git diff

# 2. ステータス確認
git status

# 3. 関係ない変更は除外
git restore <file>  # または git checkout <file>

# 4. Conventional Commits形式でコミット
git commit -m "feat: ..."

# 5. コミットメッセージを確認
git log -1
```

---

## アンチパターン

### ❌ アンチパターン1: 曖昧なメッセージ

```bash
# 悪い例
git commit -m "update"
git commit -m "fix"
git commit -m "WIP"

# 良い例
git commit -m "docs: READMEのインストール手順を更新"
git commit -m "fix: ログイン時のNullPointerExceptionを修正"
# WIPは一時的にOKだが、PR前に必ずsquashまたは書き換え
```

### ❌ アンチパターン2: mainへの直接コミット

```bash
# 悪い例
git checkout main
git commit -m "feat: 新機能"
git push origin main

# 良い例
git checkout -b feature/new-feature
git commit -m "feat: 新機能"
git push origin feature/new-feature
# Pull Requestを作成してレビュー
```

### ❌ アンチパターン3: 巨大なPull Request

```bash
# 悪い例
# 50ファイル、2000行の変更を1つのPRに

# 良い例
# 機能を段階的に分割
# PR1: モデル定義（5ファイル、200行）
# PR2: サービス実装（3ファイル、150行）
# PR3: APIエンドポイント（2ファイル、100行）
# PR4: UI実装（10ファイル、300行）
```

**原則**：1PR = 300行以下を目安に

### ❌ アンチパターン4: コミット後の force push乱用

```bash
# 危険：共有ブランチでのforce push
git push -f origin main  # 絶対NG

# 安全：自分のfeatureブランチでのみ
git push -f origin feature/my-work  # PRマージ前ならOK
```

**ルール**：
- mainブランチへの`git push -f`は禁止
- 他人と共有しているブランチへの`force push`は事前連絡

---

## 開発憲法との対応表

| Git プラクティス | 対応するValues | 説明 |
|----------------|---------------|------|
| Conventional Commits | **基礎と型** | 最小形式で最大可能性。型があるから速く動ける |
| 原子的コミット | **基礎と型** / **成長の複利** | 小さなコミットを積み重ね、長期的な品質向上 |
| 日本語メッセージ | **ニュートラル** | 誰もが使える普遍性。母国語で理解できる |
| GitHubフロー | **基礎と型** / **成長の複利** | シンプルな型で、チーム全体が一貫した運用 |
| Whyの明記 | **暗黙知の言語化** | 「なんとなく」を「明確な理由」に変換 |
| コードレビュー | **継続は力** / **成長の複利** | 教える喜び、学ぶ喜び。フィードバックを学習機会に |
| コミット履歴 = 学習資産 | **温故知新** | 過去の知恵と新しい技術を繋ぐ |

---

## FAQ

### Q1: 英語コミットメッセージと日本語、どちらが良いですか？

**A**: チームの状況により異なります。

| ケース | 推奨 | 理由 |
|--------|------|------|
| 日本人のみのチーム | **日本語** | 母国語で明確に伝えられる |
| 国際的なチーム | 英語 | 共通言語として |
| OSS プロジェクト | 英語 | グローバルな貢献者向け |

このスキルは **日本語コミットメッセージ** を前提としていますが、Conventional Commits形式は言語に依存しないため、英語でも同じ原則が適用できます。

### Q2: コミットを間違えました。どうすれば良いですか？

**A**: 状況により対処法が異なります。

```bash
# ケース1: 直前のコミットメッセージを修正
git commit --amend -m "fix: 正しいメッセージ"

# ケース2: 直前のコミットにファイルを追加
git add forgotten_file.py
git commit --amend --no-edit

# ケース3: 過去のコミットを修正（未pushの場合）
git rebase -i HEAD~3  # 過去3コミットを対話的に編集

# ケース4: 既にpushしてしまった（自分のブランチ）
git commit --amend
git push -f origin feature/my-branch

# ケース5: 既にmainにマージされた
# → 新しいコミットで修正（revertやamendは使わない）
git revert <commit-hash>
```

### Q3: Conventional Commitsのスコープは必須ですか？

**A**: いいえ、オプションです。

- **小規模プロジェクト**: スコープなしでOK
- **中～大規模プロジェクト**: スコープがあると便利
- **モノレポ**: スコープ推奨（`feat(frontend):`, `fix(backend):`）

まずはスコープなしで始め、必要性を感じたら導入してください。

### Q4: 1PRに何コミット含めるべきですか？

**A**: **1～10コミット**が目安です。

| コミット数 | 評価 | 推奨アクション |
|----------|------|-------------|
| 1～3 | ✅ 理想的 | そのままマージ |
| 4～10 | ✅ 良い | 各コミットが原子的か確認 |
| 11～20 | ⚠️ 多い | PR分割を検討 |
| 21以上 | ❌ 多すぎ | 必ず分割 |

### Q5: 「WIP」コミットは許容されますか？

**A**: 開発中は許容、PR前にクリーンアップが必要です。

```bash
# 開発中（個人ブランチ）
git commit -m "WIP: 認証機能の途中"  # OK

# PR作成前にsquashまたはrebase
git rebase -i HEAD~5
# WIPコミットをまとめて、適切なメッセージに書き換え

# 最終的なコミット
git commit -m "feat: JWT認証機能を実装"
```

### Q6: Git履歴をクリーンに保つコツは？

**A**: 以下を習慣化してください。

1. **開発中はこまめにコミット**（WIPでもOK）
2. **PR作成前に履歴を整理**（`git rebase -i`）
3. **レビュー修正は別コミット**（履歴保持）
4. **マージ時にsquash**（mainをクリーンに）

```bash
# 開発フロー例
git commit -m "WIP: モデル追加"
git commit -m "WIP: サービス実装"
git commit -m "WIP: テスト追加"

# PR作成前
git rebase -i HEAD~3
# → 3コミットを1つにまとめ、メッセージを整理

# 最終コミット
"feat: ユーザープロフィール編集機能を実装"
```

---

## まとめ

このスキルで習得できること：

✅ **Conventional Commits形式**で一貫したコミットメッセージ  
✅ **GitHubフロー**でシンプルかつ強力なブランチ戦略  
✅ **原子的コミット**でレビューしやすく、リバートしやすい履歴  
✅ **効果的な日本語メッセージ**でチーム全体が理解できる資産  
✅ **コードレビュー文化**で継続的な学習と成長  
✅ **開発憲法との整合**で、基礎と型、成長の複利を実現

**基礎があるから応用が尽きない。型があるから速く動ける。**

コミット履歴を「学習資産」に変え、チーム全体が自律成長する環境を作りましょう。

---

**作成者**: RyoMurakami1983  
**バージョン**: 1.0.0  
**ライセンス**: MIT
